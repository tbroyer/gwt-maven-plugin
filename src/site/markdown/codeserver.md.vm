#set($h2 = '##')
#set($h3 = '###')
$h2 Running and debugging

To run or debug your client-side code, use the [`gwt:codeserver`](codeserver-mojo.html) goal.
This is an aggregator goal, which means its configuration is done in your root POM, not in your `gwt-app` (in a multi-module setup).
This gives the goal the opportunity to use several `gwt-app` modules from the reactor (which it will do automatically by default).

Note that `gwt:codeserver` has a slightly different behavior than [`gwt:compile`](compile-mojo.html) to accomodate development needs.
First, the applications and all modules from the reactor that are depended on with `<type>gwt-lib</type>` or `<classifier>sources</classifier>` have their source roots used as-is so that changes can be seen immediately;
this means that if anyone of those is declared as a resource directory with filtering or relocation, behavior will be different from `gwt:compile`.
Also, dependencies by default use the `runtime` scope, whereas `gwt:compile` uses the `compile` scope;
this allows some differences between `gwt:compile` and `gwt:codeserver` classpaths when needed,
while working in identical ways most of the time (where dependencies are put in the default `compile` scope).
In any case, that behavior is configurable through the `classpathScope` property.

Starting with GWT 2.7, you should set the `launcherDir` property to get _recompile on reload._
The property should point to a folder that your web server / servlet container will look into for web resources,
so that the `*.nocache.js` file generated by the CodeServer can be loaded by your web browser.
You can find sample configuration, in combination with the Tomcat and Jetty Maven Plugins,
in the archetypes at https://github.com/tbroyer/gwt-maven-archetypes/.
In older versions of GWT, you'd have to resort to bookmarklets from a version of your app that has been compiled (and deployed) once.

Because the goal will trigger the `process-classes` phase in all modules,
it's a good idea to only include client modules in the reactor build using Maven's `-pl` argument (and don't forget the `-am` too).
If you have several `gwt-app` modules, limiting the reactor build with only a subset of them will also automatically limit the ones ran through the CodeServer.
An alternative is to use the `projects` property (or `-Dgwt.projects=` on the command-line), which can be used in profiles for instance to create presets.

The `projects` property can also be used to run the CodeServer on modules which are not `gwt-app` (e.g. `war`).
You'd then probably use it in combination with the `modules` property to define the list of GWT modules to run through the CodeServer.
By default, the ${project.name} will look for the `moduleName` property in the projects
(whether given explicitly as `projects` or the discovered `gwt-app` modules from the reactor build),
which gives you an opportunity to configure it even in non-`gwt-app` projects.

Finally, note that because the CodeServer takes a different set of arguments from the GWT Compiler,
you'll have to define some arguments twice: both in `compilerArgs` for the GWT Compiler, and in `codeserverArgs` for the CodeServer.

$h3 Standalone applications

GWT's CodeServer is great for apps for which a server serves the HTML host page,
but not so well for standalone applications,
i.e. applications that only contain client-side code (offline, or using CORS).

For standalone applications, use the [`gwt:devmode`](devmode-mojo.html) goal instead of [`gwt:codeserver`](codeserver-mojo.html).

The goals works the same, except for a few configuration properties,
and the `warDir` (somewhat equivalent to `gwt:codeserver`'s `launcherDir`) property has a default value (and is mandatory).

You'll likely want to configure at least one value in `startupUrls` pointing to an HTML host page living in the _public path_ of the module.
Have a look at the `gwt-app` integration test for an example.

Note: `gwt:devmode` can be configured for a webapp too
(provided you previously run `war:exploded` or equivalent on the server part of the application)
but this is discouraged as the webapp classloader in DevMode is somewhat broken.


$h3 Custom server in Super Dev Mode

To use a custom server in the backend (for example to enable full JEE support), use `devmodeArgs`.

$h4 WildFly

Use a WildFly server on the backend by adding the `errai-cdi-jboss` dependency and using this configuration:

```
        <plugin>
          <artifactId>gwt-maven-plugin</artifactId>
          ...
          <configuration>
            <devmodeArgs>
              <!-- GWT Super Dev Mode: Replace default backend by WildFly -->
              <arg>-server</arg>
              <arg>org.jboss.errai.cdi.server.gwt.EmbeddedWildFlyLauncher</arg>
            </devmodeArgs>
            <!-- GWT Super Dev Mode: deploy backend correctly -->
            <warDir>foo-webapp/target/foo-webapp-${project.version}</warDir>
            <systemProperties>
              <!-- GWT Super Dev Mode: which WildFly to use -->
              <errai.jboss.home>${wildfly.home}</errai.jboss.home>
              <!-- Make IDE war run config and GWT Super Dev Mode use same deployment context to avoid duplicate, conflicting deployment -->
              <errai.dev.context>foo-webapp-${project.version}</errai.dev.context>
            </systemProperties>
          </configuration>
        </plugin>
```

$h4 Remote debugging the custom server

To debug a custom server with a remote debugger from your IDE, add the `agentlib` line as a `jvmArg`:

```
        <plugin>
          <artifactId>gwt-maven-plugin</artifactId>
          ...
          <configuration>
            <jvmArgs>
              <arg>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</arg>
            </jvmArgs>
            ...
          </configuration>
        </plugin>
```

